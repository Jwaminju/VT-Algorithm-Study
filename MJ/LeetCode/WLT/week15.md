** 문제 풀이 **
- 처음에는 brute-force 방식으로 풀어서 시간초과가 떴다. 이는 가능한 모든 subarray의 경우를 조회한 것이지, 그 중에서 maximum multiple value를 찾는 과정은 하나도 없기 때문이다.
- 일반적인 dp문제와 다르게 풀었던 부분은, dp[i]가 하나의 dp[i-1]로 결정되는 것이 아니라, dp[i-1]이 여러 개라서 dp[i]도 여러 개가 될 수 있다는 점이었다. 이는 dp[i]가 i번째 숫자로 끝나는 subarray의 최대 multiple value가 아니라, i번째 숫자로 끝나는 subarray의 muliple value가 될 수 있는 수로 정의되었기 때문이다. 왜냐하면 뒤에 어떤 숫자가 나오느냐에 따라서 (음수가 있기 때문에) 곱셈의 결과를 당장 결정지을 수 있는 것이 아니기 때문이다. 따라서 O(3n)으로 해결할 수 있었다.
- 또한, dp[i]를 저장할 때, set()을 써서 시간 초과를 해결하였는데, 이는 조회해야 할 중복되는 수를 줄였기 때문이다. 중복된 값을 조회하지 않도록 처리해주지 않으면 최악의 경우 O(n^2)가 나올 수 있다. 

** 코드 리뷰 **
- 다른 사람의 풀이를 보니, minCur, maxCur을 써서 해결하였다. O(3n)이 나오는 이유도, 결국 절댓값으로 가장 큰 숫자를 선택하는 과정이라 결국 같은 과정이었다.
- 특히, 다른 사람의 풀이를 보니 메모이제이션을 사용하지 않았다. dp이지만, 이전 값을 사용할 뿐, 이전 값을 저장해두지는 않는다. 나도 for문에서 dp[i]가 리스트라면, 더이상 dp[i]은 다음 스텝에서는 쓰이지 않기 때문에 리스트에 있는 것 중 가장 max 값만 남겨두었다. 이 말은, 즉 저장해둘 필요가 없다는 것이고 메모리를 아낄 수 있는 부분이라 내 submission 코드에 반영하였다. 이를 통해 메모리를 1MB 줄여서 beats 5%에서 beats 68%로 향상시킬 수 있었다.